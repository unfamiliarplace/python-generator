'use strict';import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,__ipow__,
__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,all,any,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,filter,float,getattr,
hasattr,input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";var __name__="data.real_world.real_world_lines";export var REAL_WORLD_TEXT="\nimport timeit\nimport random\nfrom pandas import Series\nfrom numpy import array\n\n_L = [random.randint(1, 1_000) for _ in range(1_000)]\n\ndef _plus5(n):\n    return n + 5\n\ndef loop_build_add(L):\n    L2 = []\n    for elem in L:\n        L2 = L2 + [elem + 5]\n\ndef loop_build_increment(L):\n    L2 = []\n    for elem in L:\n        L2 += [elem + 5]\n\ndef loop_build_append(L):\n    L2 = []\n    for elem in L:\n        L2.append(elem + 5)\n\ndef loop_build_extend(L):\n    L2 = []\n    for elem in L:\n        L2.extend([elem + 5])\n\ndef loop_build_zeroes(L):\n    L2 = [0] * len(L)\n    for i in range(len(L)):\n        L2[i] = L[i] + 5\n\ndef loop_inplace_add(L):\n    for i in range(len(L)):\n        L[i] = L[i] + 5\n\ndef loop_inplace_increment(L):\n    for i in range(len(L)):\n        L[i] += 5\n\ndef map_gen(L):\n    map(_plus5, L)\n\ndef map_cast(L):\n    list(map(_plus5, L))\n\ndef listcomp_gen(L):\n    (elem + 5 for elem in L)\n\ndef listcomp_cast(L):\n    [elem + 5 for elem in L]\n\ndef pandas_series(L):\n    Series(L) + 5\n\ndef pandas_series_cast(L):\n    (Series(L) + 5).tolist()\n\ndef numpy_array(L):\n    array(L) + 5\n\ndef numpy_array_cast(L):\n    (array(L) + 5).tolist()\n\nmethods = [\n    loop_build_add,       # takes obnoxiously long, about 1 order of magnitude more\n    loop_build_increment,\n    loop_build_append,\n    loop_build_extend,\n    loop_build_zeroes,\n    loop_inplace_add,\n    loop_inplace_increment,\n    map_gen,\n    map_cast,\n    listcomp_gen,\n    listcomp_cast,\n    pandas_series,\n    pandas_series_cast,\n    numpy_array,\n    numpy_array_cast\n]\n\nfor cb in methods:\n    result = timeit.timeit(lambda: cb(_L[:]), number=10_000)\n    print(f'{cb.__name__: <25}{result:.5f}')\n# This script allows you modify a subtitle file by a given offset.\n\n# IMPORTS\n\nimport re\n\n# CONSTANTS\n\n# Example line: 00:00:33,159 --\x3e 00:00:35,999\nMARKER      = '--\x3e'\nMIN         = 60000\nHR          = 60 * MIN\nTS          = r'<p begin=\"(.*?)\" end=\"(.*?)\" region=\"AmazonDefaultRegion\" style=\"AmazonDefaultStyle\">(.*?)</p>'\n\n# WORKING WITH TIMESTAMPS\n\ndef parse_ts(ts: str) -> int:\n    \"\"\"Return the number of milliseconds in a given timestamp.\"\"\"\n\n    # Get the separate parts\n    hrs, mins, ms = ts.split(':')\n    ms = ms.replace('.', '')\n\n    # Turn them into a single int\n    ms = int(ms)\n    ms += int(mins) * MIN\n    ms += int(hrs) * HR\n\n    return ms\n\n\ndef format_ts(ms: int) -> str:\n    \"\"\"Format the given milliseconds as a timestamp.\"\"\"\n\n    hrs = 0\n    mins = 0\n\n    # Count hours\n    while ms > HR:\n        ms -= HR\n        hrs += 1\n\n    # Count minutes\n    while ms > MIN:\n        ms -= MIN\n        mins += 1\n\n    # Format\n    ts = '{}:{}:{}'.format(\n        str(hrs).zfill(2),\n        str(mins).zfill(2),\n        str(ms).zfill(5)\n    )\n\n    ts = ts[:-3] + ',' + ts[-3:]\n    return ts\n\ndef format_sub(start, end, sub) -> str:\n    \"\"\"Return a formatted subtitle.\"\"\"\n\n    sub = sub.replace('<br />', '\\]n')\n    if sub.startswith(\"'\") and sub.endswith(\"'\"):\n        sub = f'<i>{sub[1:-1]}</i>'\n\n    start = format_ts(parse_ts(start))\n    end = format_ts(parse_ts(end))\n\n    return f'{start} --\x3e {end}\\n{sub}'\n\n# WORKING WITH LINES\n\ndef convert_line(line: str) -> str:\n    match = re.search(TS, line)\n    if match:\n        start, end, sub = match.group(1), match.group(2), match.group(3)\n        return format_sub(start, end, sub)    \n\ndef convert_lines(lines: list) -> iter:\n    i = 1\n    for line in lines:\n        conv = convert_line(line)\n        if conv:\n            yield f'{i}\\n{conv}'\n            i += 1\n\n# RUNNING\n\ndef prompt_fname() -> str:\n    \"\"\"Return a str (filename).\"\"\"\n\n    fname = input('Enter the name of a subtitle file: ').strip()\n    return fname\n\ndef prompt_offset() -> int:\n    \"\"\"Return an int (milliseconds offset).\"\"\"\n\n    offset = int(input('Enter an offset in milliseconds: ').strip())\n    return offset\n\ndef get_fix_fname(fname: str) -> str:\n    \"\"\"Return the filename for the fixed version.\"\"\"\n    \n    return f'{fname[:fname.rfind(\".\")]}_fix.srt'\n    \n\ndef run() -> None:\n    \"\"\"Open file, correct each line, save to new file.\"\"\"\n\n    # Determine filenames and offset\n    fname = prompt_fname()\n    fname_fix = get_fix_fname(fname)\n\n    with open(fname, 'r') as f, open(fname_fix, 'w') as f_fix:\n        lines = convert_lines(f.readlines())\n        f_fix.write('\\n\\n'.join(lines))\n\n    # Report \n    input('Saved to {}\\nPress Enter to quit.'.format(fname_fix))\n\n\n# PROGRAM\n\nif __name__ == '__main__':\n    run()\ndef count_lines():\n    \n    while True:\n        filename = input('Enter a filename: ')\n        \n        try:\n            file = open(filename, 'r')\n            break\n        except(FileNotFoundError):\n            print(\"Couldn't find that file.\")\n            \n    lines = 0\n    for line in file:\n        line = line.strip()\n        lines += bool(line)\n    file.close()\n    \n    print('{} non-empty lines.'.format(lines))\n        \ncount_lines()\n# Imports\nimport random\n\nprint()\ninput('Enter to quit')\nimport requests\nimport os\nimport shutil\n\ndir_out = './output'\nif not os.path.exists(dir_out):\n    os.mkdir(dir_out)\n\nplaceholder = '****'\n\nstem_host = 'https://ia803205.us.archive.org'\nstem_dir = 'BookReader/BookReaderPreview.php'\nstem_data = {\n    'id'        : 'seizeday0000bell_x5c5',\n    'subPrefix' : 'seizeday0000bell_x5c5',\n    'itemPath'  : '/13/items/seizeday0000bell_x5c5',\n    'server'    : 'ia803205.us.archive.org',\n    'page'      : f'leaf{placeholder}',\n    'fail'      : 'preview',\n    'scale'     : '1',\n    'rotate'    : '0'\n}\n\nstem2_host = 'https://ia903205.us.archive.org'\nstem2_dir = 'BookReader/BookReaderImages.php'\nstem2_data = {\n    'zip'       : '/13/items/seizeday0000bell_x5c5/seizeday0000bell_x5c5_jp2.zip',\n    'file'      : f'seizeday0000bell_x5c5_jp2/seizeday0000bell_x5c5_{placeholder}.jp2',\n    'id'        : 'id=seizeday0000bell_x5c5',\n    'scale'     : '1',\n    'rotate'    : '0'\n}\n\n\ndef construct_url(n: int) -> str:\n    url = f'{stem_host}/{stem_dir}'\n    data = stem_data.copy()\n    data['page'] = data['page'].replace(placeholder, str(n))\n    argstr = '&'.join(f'{k}={v}' for (k, v) in data.items())\n    return f'{url}?{argstr}'\n\ndef construct_url2(n: int) -> str:\n    url = f'{stem2_host}/{stem2_dir}'\n    data = stem2_data.copy()\n    data['file'] = data['file'].replace(placeholder, f'{n:0>4}')\n    argstr = '&'.join(f'{k}={v}' for (k, v) in data.items())\n    return f'{url}?{argstr}'    \n\ndef construct_a(url: str, n: int) -> str:\n    return f'<a href=\"{url}\">{n:0>4}.jpg</a>'\n\n\nfor i in range(8, 149):\n    url = construct_url2(i)\n    a = construct_a(url, i)\n    print(a)\n\n    \n    continue\n    \n    r = requests.get(url, stream=True)\n    \n    if r.status_code == 200:    \n        fname = f'{dir_out}/{i:0>4}.jpg'\n        with open(fname, 'wb') as f:\n            shutil.copyfileobj(r.raw, f)\n        print(f'Downloaded {i:0>4}')\n    else:\n        print(f'Unable to download {i:0>4}')\n\n    \n# https://zeldauniverse.net/media/music/links-awakening-original-soundtrack/\n\nimport urllib.request\nimport requests\nDIR_DL = 'E:/Luke/Desktop/link'\nSRC_LIST = 'E:/Luke/Desktop/src.txt'\nEXT = 'mp3'\n\n# gather urls\n\nurls = []\nwith open(SRC_LIST, 'r') as f:\n    urls = (L.strip() for L in f.readlines())\n\n        \n# download over https\n            \nfor url in urls:\n    fname = url[url.rfind('/')+1:]\n    \n    r = requests.get(url)\n    if r.status_code != 200:\n        print(f'Could not access {fname}. trying other method')\n        urllib.request.urlretrieve(url, f'{DIR_DL}/{fname}')\n    else:\n        with open(f'{DIR_DL}/{fname}', 'wb') as f:\n            f.write(r.content)\n        print(f'Downloaded {fname}')\n\n\n# download over http\n           \n##for url in urls:\n##    fname = url[url.rfind('/')+1:]\n##    urllib.request.urlretrieve(url, f'{DIR_DL}/{fname}')\n# https://zeldauniverse.net/media/music/links-awakening-original-soundtrack/\n\nimport urllib.request\nimport requests\nimport os\n\nDIR_DL = 'link'\nSRC_HTML = 'src.txt'\nREL_BASE = 'http://galactic-voyage.com'\nEXT = 'mp3'\n\n# gather urls\n\nurls = []\nwith open(SRC_HTML, 'r') as f:\n    content = f.read()\n    i = 0\n    url = ''\n    while i < len(content):\n        if content[i] == 'a' and content[i:i+8] == 'a href=\"':\n            url = content[i+8:content.find('\"', i+8)]\n            if EXT in url:\n                urls.append(url)\n        i += 1\n\n# get src as inputs instead of constants\n# TODO\n\n# make output folder\nif not os.path.exists(DIR_DL):\n    os.mkdir(DIR_DL)\n        \n# download over https\n            \nfor url in urls:\n    if not url.startswith('http'):\n        url = f'{REL_BASE}/{url}'\n    fname = url[url.rfind('/')+1:]\n    \n    r = requests.get(url)\n    if r.status_code != 200:\n        print(f'Could not access {fname}')\n    else:\n        with open(f'{DIR_DL}/{fname}', 'wb') as f:\n            f.write(r.content)\n        print(f'Downloaded {fname}')\n\n\n# download over http\n           \n##for url in urls:\n##    fname = url[url.rfind('/')+1:]\n##    urllib.request.urlretrieve(url, f'{DIR_DL}/{fname}')\nno_words = {\n    1: set(),\n    2: set(),\n    3: set(),\n    4: set()\n}\n\nyes_words = {\n    1: set(),\n    2: set(),\n    3: set(),\n    4: set()\n}\n\n# load already filtered\nwith open('cmudict_no.txt', 'r') as f:\n    adding_to = no_words\n    for line in f.readlines():\n        word = line.strip()\n\n        # skip comment\n        if word.startswith('#'):\n            continue\n\n        # switch if we hit the blank line\n        if not word:\n            adding_to = yes_words\n        else:  \n            adding_to[len(word)].add(word)\n\n# go through rest\nwith open('cmudict.txt', 'r') as f:\n    i = 0\n    lines = f.readlines()\n    while i < len(lines):\n        line = lines[i]\n        word = line.split(' ')[0]\n        \n        if (len(word) in no_words) and all(c.isalpha() for c in word):\n            if word not in no_words[len(word)] and word not in yes_words[len(word)]:\n                keep = input(f'Q | Enter | . | +WORD | -WORD < {word.lower()} : ').lower().strip()\n\n                if keep == 'q':\n                    i = len(lines)\n                    \n                elif keep == '.':\n                    yes_words[len(word)].add(word)\n                    \n                elif keep.startswith('+'):\n                    restore = keep.split('+')[1].strip().upper()\n                    if restore in yes_words[len(restore)]:\n                        yes_words[len(restore)].add(restore)\n                    if restore in no_words[len(restore)]:\n                        no_words[len(restore)].remove(restore)\n                    print(f'restored {restore}')\n                    i -= 1\n                    \n                elif keep.startswith('-'):\n                    drop = keep.split('-')[1].strip().upper()\n                    if drop in no_words[len(drop)]:\n                        no_words[len(drop)].add(drop)\n                    if drop in yes_words[len(drop)]:\n                        yes_words[len(drop)].remove(drop)\n                    print(f'dropped {drop}')\n                    i -= 1\n                    \n                else:\n                    no_words[len(word)].add(word)\n        i += 1\n\n# save all\nwith open('cmudict_no.txt', 'w') as f:\n    f.write('# no words\\n')\n    for length in sorted(no_words.keys()):\n        for word in sorted(no_words[length]):\n            f.write(word + '\\n')\n    f.write('\\n# yes words\\n')\n    for length in sorted(yes_words.keys()):\n        for word in sorted(yes_words[length]):\n            f.write(word + '\\n')\n\nfor i in range(1, 101):\n    th = bool(i % 3)\n    fi = bool(i % 5)\n    p = str(i) * (not (th or fi))\n    p += 'Fizz' * (not th)\n    p += 'Buzz' * (not fi)\n    print(p)\n    \nimport os\n\nfor item in list(os.walk('.'))[0][2]:\n    if item.endswith('flac'):\n        with open(f'{item}.txt', 'w') as f:\n            f.write('\\n')\n\nimport os\n\nfor item in list(os.walk('.'))[0][2]:\n    if item.endswith('flac'):\n        with open(f'{item}.txt', 'w') as f:\n            f.write('\\n')\n\nimport os\nimport sys\n\nTHIS = 'listify.py'\nSAFE = '_original'\n\ncwd = os.getcwd()\nyn = input(f'About to listify {cwd}. Enter \"Y\" to proceed: ')\nif yn.strip().upper().startswith('Y'):\n    print('OK, going')\nelse:\n    input('Did not listify. Hit Enter to quit')\n    sys.exit()\n\nif not os.path.exists(SAFE):\n    os.mkdir(SAFE)\n\nfor _, _, files in os.walk('.'):\n    for fname in files:\n        if fname == THIS:\n            continue\n        \n        os.rename(fname, f'{SAFE}/{fname}')\n        with open(f'{fname}.txt', 'w') as f:\n            f.write(fname)\n\n    # Just top level ...\n    break\n\nprint(f'Listified {cwd}')\ninput('Hit Enter to quit')\ndef m_to_d_1(m: int) -> int:\n    \"\"\"Hardcoding each relation\"\"\"\n\n    if m == 1:\n        return 31\n    elif m == 2:\n        return 28\n    elif m == 3:\n        return 31\n    elif m == 4:\n        return 30\n    elif m == 5:\n        return 31\n    elif m == 6:\n        return 30\n    elif m == 7:\n        return 31\n    elif m == 8:\n        return 31\n    elif m == 9:\n        return 30\n    elif m == 10:\n        return 31\n    elif m == 11:\n        return 30\n    elif m == 12:\n        return 31\n\n\ndef m_to_d_2(m: int) -> int:\n    \"\"\"Hardcoding each relation, but code golfed\"\"\"\n    \n    return int('312831303130313130313031'[(m - 1) * 2:][:2])\n\ndef m_to_d_3(m: int) -> int:\n    \"\"\"First attempt to find a pattern\"\"\"\n    \n    if m == 2:\n        return 28\n    elif m < 8:\n        return 30 + m % 2\n    else:\n        return 31 - m % 2\n\ndef m_to_d_4(m: int) -> int:\n    \"\"\"Same as 3 but as an expression instead of with control keywords\"\"\"\n\n    return 28 + (2 * (m != 2)) + ((m < 8 and m % 2) or (m > 7 and not (m % 2)))\n\n\n\nmonths = list(range(1, 13))\ncheck = [m_to_d_1(m) for m in months]\ntest = [m_to_d_4(m) for m in months]\nprint(check == test)\ndef get_baskets_left(thousands, loaves):\n    \n    # http://www.biblegateway.com/passage/?search=mark%208:19-21&version=NIV\n    \n    if thousands == loaves:\n        return 12\n    else:\n        return loaves\n\ntemp_loaves = int(input('How many loaves?: '))    \ntemp_thousands = int(input('How many thousands of people?: '))\nprint('{} baskets left over.'.format(get_baskets_left(temp_thousands, temp_loaves)))\nprint(\" \")\nprint(\"Guess the number. You may only enter numerals.\")\nprint(\"...It is winnable. >:)\")\nprint(\" \")\n\na = 0\n\nwhile a == 0:\n    x = float(input(\"How many? \"))\n    if x > 17.5 and x != 71:\n        print(\"Not enough.\")\n        print(\" \")\n    elif x < 17.5:\n        print(\"Too many.\")\n        print(\" \")\n    else:\n        print(\"Yeah!\")\n        print(\"A chocolate bar is totally coming your way.\")\n        print(\"Any time now.\")\n        a = 1\n        \ninput()\nimport os, time\nos.chdir('C:\\')\n\nROWS = 15000\nVARS = 34\nMULT = 7\n\nT_1 = time.time()\nprint(f'Started at {T_1}')\n\nf = open('test.csv', 'w')\n\nfor i in range(ROWS):\n    row = ''\n    for v in range(VARS):\n        row += f'{v};'\n    f.write(row + '\\n')\n\nf.close()\n\nT_2 = time.time()\nprint(f'Time to finish original seed: {T_2 - T_1}')\n\nf = open('test.csv', 'r')\nf2 = open('testx7.csv', 'w')\n\nfor line in f.readlines():\n    rows = [''] * MULT\n    \n    for item in line.split(';'):\n        if item != '\\n':\n            div = int(item) / MULT\n            for i in range(MULT):\n                rows[i] += f'{div};'\n\n    for row in rows:\n        f2.write(row + '\\n')\n\nf.close()\nf2.close()\n\nT_3 = time.time()\nprint(f'Time to finish multiplication: {T_3 - T_2}')\n\nprint('Finished at {T_3}')\n\nnumber = '8738942'\nletters = {\n    '2': set('ABC'),\n    '3': set('DEF'),\n    '3': set('GHI'),\n    '4': set('JKL'),\n    '6': set('MNO'),\n    '7': set('PQRS'),\n    '8': set('TUV'),\n    '9': set('WXYZ')\n}\nallowed = set('MNODEFWXYZ')\n\nwords2 = set()\nwords2end = set()\nwords2mid = set()\nwords3 = set()\nwords3end = set()\nwords4 = set()\nwords4end = set()\nwords5 = set()\nwords5end = set()\nwords7 = set()\nlengths = {2, 3, 4, 5, 7}\n\nwords = {\n    7: words7,\n    5: words5,\n    4: words4,\n    3: words3,\n    2: words2,\n    1005: words5end,\n    1004: words4end,\n    1003: words3end,\n    1002: words2end,\n    2002: words2mid\n}\n\ndef can_make(word: str, offset: int=0) -> bool:\n    for i, c in enumerate(word):\n        if c not in letters[number[i + offset]]:\n            return False\n    else:\n        return True\n\ndef can_start(word: str) -> bool:\n    return can_make(word)\n\ndef can_end(word: str) -> bool:\n    return can_make(word, len(number) - len(word))    \n    \n\nwith open('cmudict.txt', 'r') as f:\n    for line in f.readlines():\n        word = line.split(' ')[0]\n        n = len(word)\n        if n in lengths:\n            if can_start(word):\n                words[n].add(word)\n            if can_end(word):\n                words[n + 1000].add(word)\n            if n == 2 and can_make(word, 3):\n                words[2002].add(word)\n\n\npossible = set()\n\nfor word5 in words5:\n    for word2 in words2:\n        possible.add(f'{word5} {word2}')\n\nfor word4 in words4:\n    for word3 in words3end:\n        possible.add(f'{word4} {word3}')\n\nfor word3 in words3:\n    for word4 in words4end:\n        possible.add(f'{word3} {word4}')\n    for word2mid in words2mid:\n        for word2end in words2end: # happens to be 63 at start and end\n            possible.add(f'{word3} {word2mid} {word2end}')\n\nfor word2 in words2:\n    for word5 in words5end:\n        possible.add(f'{word2} {word5}')\n\nfor word in sorted(possible, key=len, reverse=True):\n    print(word)\n\nLETTERS = {\n    # 0 is a space and 1 maps to no letters\n    '2': set('ABC'),\n    '3': set('DEF'),\n    '4': set('GHI'),\n    '5': set('JKL'),\n    '6': set('MNO'),\n    '7': set('PQRS'),\n    '8': set('TUV'),\n    '9': set('WXYZ'),\n}\n\nprompt = \"\"\"Enter here:\"\"\"\n\nno_words = set()\n\nwith open('cmudict_no.txt', 'r') as f:\n    for word in f.readlines():\n        word = word.strip()\n\n        # Skip comments\n        if word.startswith('#'):\n            continue\n\n        # Stop when we get to the yes words\n        if not word:\n            break\n        \n        no_words.add(word)\n\nwith open('cmudict.txt', 'r') as f:\n    lines = f.readlines()\n    \n\ndef extract_pieces(number: str) -> dict:\n    pieces = {}\n    for line in lines:\n        word = line.split(' ')[0]\n        n = len(word)\n        \n        # exception for ridiculous words...\n        if word in no_words:\n            if word == 'ME':\n                print(word)\n            continue\n        \n        for i in range(len(number)):\n            if can_make(number, word, i):\n                if n not in pieces:\n                    pieces[n] = {}\n                if i not in pieces[n]:\n                    pieces[n][i] = set()\n                \n                pieces[n][i].add(word)\n    return pieces\n\ndef can_make(number: str, word: str, offset: int=0) -> bool:\n    if len(word) + offset > len(number):\n        return False\n    \n    for i, c in enumerate(word):\n        if c not in LETTERS[number[i + offset]]:\n            return False\n    else:\n        return True\n\ndef can_start(number: str, word: str) -> bool:\n    return can_make(number, word)\n\ndef can_end(number: str, word: str) -> bool:\n    return can_make(number, word, len(number) - len(word))\n\ndef construct_phrases(number: str, pieces: dict) -> set:\n\n    def _recurse(sub_number: str, phrase: str) -> set:\n\n        # at each level, we get the remaining number,\n        # and the word we're building up to that point.\n\n        # for all words of the remaining length or less\n        # at that offset, recurse using said word and\n        # the number less than that word.\n\n        # said recursion returns a set of phrases.\n        # return a set consisting of the current word\n        # concatenated with each of those phrases.\n\n        # Base case: end of the word\n        \n        if not sub_number:\n            return {phrase}\n        \n        else:\n            phrases = set()\n            i = len(number) - len(sub_number)\n            \n            for n in (n for n in pieces if n <= len(sub_number)):\n                for word in pieces[n].get(i, ()):\n                    subphrases = _recurse(sub_number[len(word):], word)\n                    for subphrase in subphrases:\n                        phrases.add(f'{phrase} {subphrase}')\n            return phrases\n\n    return _recurse(number, '')\n\ndef find_phrases(number: str) -> set:\n    pieces = extract_pieces(number)\n    return construct_phrases(number, pieces)\n\ndef chain(sets: list) -> list:\n    if len(sets) == 1:\n        return sets[0]\n    else:\n        words = []\n        for outer in sets[0]:\n            for inner in chain(sets[1:]):\n                words.append(f'{outer}{inner}')\n        return words\n\ndef multi_split(s: str, seps: str) -> list:\n    parts = []\n    part = ''\n    for c in s:\n        if (c in seps) and part:\n            parts.append(part)\n            part = ''\n        else:\n            part += c\n    if part:\n        parts.append(part)\n    return parts\n\ndef sub_combos(number: str) -> list:\n    sets = []\n    parts = multi_split(number, '01')\n    for part in parts:\n        sets.append(find_phrases(part))\n    sets = list(filter(lambda s: s, sets))\n    return chain(sets) if sets else []\n\ndef sanitize_number(number: str) -> str:\n    return ''.join(list(filter(lambda c: c.isdigit(), number)))\n\ndef run() -> None:\n    number = sanitize_number(input(prompt))\n    words = sub_combos(number)\n    if not words:\n        print('No words found')\n    else:\n        for word in sorted(words):\n            print(word)\n\nif __name__ == '__main__':\n    run()\n# TODO FOR v3\n# hyphens to differentiate from spaces?\n# option to filter stupid words?\n# display original number for unused sections\n\nLETTERS = {\n    # 0 is a space and 1 maps to no letters\n    '2': set('ABC'),\n    '3': set('DEF'),\n    '4': set('GHI'),\n    '5': set('JKL'),\n    '6': set('MNO'),\n    '7': set('PQRS'),\n    '8': set('TUV'),\n    '9': set('WXYZ'),\n}\n\nprompt = \"\"\"Enter here: \"\"\"\n\nno_words = set()\n\nwith open('cmudict_no.txt', 'r') as f:\n    for word in f.readlines():\n        word = word.strip()\n\n        # Skip comments\n        if word.startswith('#'):\n            continue\n\n        # Stop when we get to the yes words\n        if not word:\n            break\n        \n        no_words.add(word)\n\nwith open('cmudict.txt', 'r') as f:\n    lines = f.readlines()\n    \n\ndef extract_pieces(number: str) -> dict:\n    pieces = {}\n    for line in lines:\n        word = line.split(' ')[0]\n        n = len(word)\n        \n        # exception for ridiculous words...\n        if word in no_words:\n            if word == 'ME':\n                print(word)\n            continue\n        \n        for i in range(len(number)):\n            if can_make(number, word, i):\n                if n not in pieces:\n                    pieces[n] = {}\n                if i not in pieces[n]:\n                    pieces[n][i] = set()\n                \n                pieces[n][i].add(word)\n    return pieces\n\ndef can_make(number: str, word: str, offset: int=0) -> bool:\n    if len(word) + offset > len(number):\n        return False\n    \n    for i, c in enumerate(word):\n        if c not in LETTERS[number[i + offset]]:\n            return False\n    else:\n        return True\n\ndef can_start(number: str, word: str) -> bool:\n    return can_make(number, word)\n\ndef can_end(number: str, word: str) -> bool:\n    return can_make(number, word, len(number) - len(word))\n\ndef construct_phrases(number: str, pieces: dict) -> set:\n\n    def _recurse(sub_number: str, phrase: str) -> set:\n\n        # at each level, we get the remaining number,\n        # and the word we're building up to that point.\n\n        # for all words of the remaining length or less\n        # at that offset, recurse using said word and\n        # the number less than that word.\n\n        # said recursion returns a set of phrases.\n        # return a set consisting of the current word\n        # concatenated with each of those phrases.\n\n        # Base case: end of the word\n        \n        if not sub_number:\n            return {phrase}\n        \n        else:\n            phrases = set()\n            i = len(number) - len(sub_number)\n            \n            for n in (n for n in pieces if n <= len(sub_number)):\n                for word in pieces[n].get(i, ()):\n                    subphrases = _recurse(sub_number[len(word):], word)\n                    for subphrase in subphrases:\n                        phrases.add(f'{phrase} {subphrase}')\n            return phrases\n\n    return _recurse(number, '')\n\ndef find_phrases(number: str) -> set:\n    pieces = extract_pieces(number)\n    return construct_phrases(number, pieces)\n\ndef chain(sets: list) -> list:\n    if len(sets) == 1:\n        return sets[0]\n    else:\n        words = []\n        for outer in sets[0]:\n            for inner in chain(sets[1:]):\n                words.append(f'{outer}{inner}')\n        return words\n\ndef multi_split(s: str, seps: str) -> list:\n    parts = []\n    part = ''\n    for c in s:\n        if (c in seps) and part:\n            parts.append(part)\n            part = ''\n        else:\n            part += c\n    if part:\n        parts.append(part)\n    return parts\n\ndef sub_combos(number: str) -> list:\n    sections = []\n    parts = multi_split(number, '01')\n    print(parts)\n    for part in parts:\n        sections.append(find_phrases(part))\n    for (i, section) in enumerate(sections):\n        if not section:\n            sections[i] = parts[i]\n        \n    return chain(sections) if sections else []\n\ndef sanitize_number(number: str) -> str:\n    return ''.join(list(filter(lambda c: c.isdigit(), number)))\n\ndef run() -> None:\n    number = sanitize_number(input(prompt))\n    words = sub_combos(number)\n    if not words:\n        print('No words found')\n    else:\n        for word in sorted(words):\n            print(word)\n\nif __name__ == '__main__':\n    run()\n##def count(rem):\n##    \n##    if rem < 2:\n##        return rem\n##    else:\n##        return 2 + count(rem - 1) + count(rem - 2)\n\n\ndef count(rem: int) -> int:\n    '''\n    A short staircase consists of n steps. Sometimes you take 1 step\n    at a time, sometimes 2. How many possible ways to go down the stairs\n    are there?\n    '''\n\n    if rem < 2:\n        return 1\n    else:\n        return count(rem - 1) + count(rem - 2) \n# in mac filenames, 'a_' sorts before 'a'\n# in pc filenames, 'a' sorts before 'a_'\n# this script takes the mac system and just renumbers files without underscores\n\nimport os\nimport functools\n\nfnames = {}\n\nfor fname in list(os.walk('.'))[0][2]:\n    if '.py' in fname:\n        continue\n    \n    fnames[fname] = []\n\ndef _strcmp(a, b):\n    if a < b:\n        return -1\n    elif b < a:\n        return 1\n    else:\n        return 0\n\ndef _undercmp(a, b):\n    a = a.split('.')[0]\n    b = b.split('.')[0]\n    if a.rstrip('_') == b.rstrip('_'):\n        if len(a) > len(b):\n            return -1\n        elif len(b) > len(a):\n            return 1\n        else:\n            return 0\n    else:\n        return _strcmp(a, b)\n\ndef new_fname_1(i, ext):\n    return str(i) + '.' + ext\n\ndef new_fname_2(i, ext):\n    return chr(i + 97) + '.' + ext\n\nfnames_sorted = sorted(fnames, key=functools.cmp_to_key(_undercmp))\nfnames_2 = {}\n\nfor (i, fname) in enumerate(fnames_sorted):\n    ext = fname.split('.')[1]\n    fnames[fname] = new_fname_1(i, ext)\n    fnames_2[new_fname_1(i, ext)] = new_fname_2(i, ext)\n\nfor (old, new) in fnames.items():\n    os.rename(old, new)\n\nfor (old, new) in fnames_2.items():\n    os.rename(old, new)\nimport random\n\nR = 'ROCK'\nP = 'PAPER'\nS = 'SCISSORS'\n\nclass Player:\n    def __init__(self, name: str):\n        self.name = name\n        self.roll = None\n\n    def fight(self, other):\n        if self.roll == other.roll:\n            return None\n\n        if self.roll == R:\n            return self if other.roll == S else other\n        elif self.roll == P:\n            return self if other.roll == R else other\n        elif self.roll == S:\n            return self if other.roll == P else other\n\ndef run():\n    name = input('Your name: ').strip()\n    user = Player(name)\n    comp = Player('ATM')\n\n    wins = 0\n    go = ''\n\n    while go != 'Q':\n        roll = input('R/P/S: ').strip().upper()\n        user.roll = eval(roll)\n        comp.roll = random.choice((R, P, S))\n        print('{} rolled {}'.format(comp.name, comp.roll))\n\n        winner = user.fight(comp)\n        wins += winner == user\n        winner = 'Tie!' if not winner else winner.name\n        print('Winner: {}'.format(winner))\n        print('Your wins: {}'.format(wins))\n\n        go = input('\\nEnter to play again, Q to quit: ').strip().upper()\n\nif __name__ == '__main__':\n    run()\n    \ndef off_square(lower: int, distance: int) -> int:\n    upper = lower + distance\n    mean = lower + (distance / 2)\n    return mean**2 - (lower * upper)\n\ndef test(upper: int) -> None:\n    for n in range(1, upper + 1):\n        for distance in range(0, 9):\n            off = off_square(n, distance)\n            if off != (distance / 2)**2:\n                print(f'{n} * {n+(distance * 2)} is {off} less than {n+distance}^2')\n\ntest(1000)\n\n# 16 x 16 = 0 less than 16 x 16\n# 15 x 17 = 1 less than 16 x 16\n# 14 x 18 = 4 less than 16 x 16\n# 13 x 19 = 9 less than 16 x 16\n\n# Moreover, even with non-integer means\n# 15 x 16 = 0.25 less than 15.5 x 15.5\n# 15 x 18 = 2.25 less than 16.5 x 16.5\n\n# Square the distance from the middle #\n\n# For any two numbers a and b, let c be their average.\n# The product of any two numbers is\n# equal to the square of their mean minus the square of half their range.\ndef any_base_to_int(n: str, base: int) -> int:\n    result = 0\n    mult = 1\n\n    for i in range(len(n)):\n        digit = int(n[-(i + 1)])\n        result += digit * mult\n        mult *= base\n\n    return result\n\ndef vindicate_douglas_adams():\n    assert 6 * 9 == any_base_to_int('42', 13)\n";
export var REAL_WORLD_LINES=REAL_WORLD_TEXT.py_split("\n").__getslice__(1,-1,1);var REAL_WORLD_LINES=list(filter(function __lambda__(L){if(arguments.length){var __ilastarg0__=arguments.length-1;if(arguments[__ilastarg0__]&&arguments[__ilastarg0__].hasOwnProperty("__kwargtrans__")){var __allkwargs0__=arguments[__ilastarg0__--];for(var __attrib0__ in __allkwargs0__)switch(__attrib0__){case "L":var L=__allkwargs0__[__attrib0__];break}}}else;return bool(L.strip())},REAL_WORLD_LINES));

//# sourceMappingURL=data.real_world.real_world_lines.map