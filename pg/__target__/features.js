'use strict';import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,__ipow__,
__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,filter,float,getattr,hasattr,
input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";var __name__="features";export var names=["comments","statements","expressions","decorators","symbol_practice","real_world","variables","math","strings","booleans","containers","control","indexing","maps","imports","functions","methods","classes","files"];export var py_values=
dict({});export var reset_features=function(polarity){if(typeof polarity=="undefined"||polarity!=null&&polarity.hasOwnProperty("__kwargtrans__"))var polarity=false;if(arguments.length){var __ilastarg0__=arguments.length-1;if(arguments[__ilastarg0__]&&arguments[__ilastarg0__].hasOwnProperty("__kwargtrans__")){var __allkwargs0__=arguments[__ilastarg0__--];for(var __attrib0__ in __allkwargs0__)switch(__attrib0__){case "polarity":var polarity=__allkwargs0__[__attrib0__];break}}}else;for(var py_name of names)py_values[py_name]=
polarity};export var update_features=function(current_features){if(typeof current_features=="undefined"||current_features!=null&&current_features.hasOwnProperty("__kwargtrans__"))var current_features=dict({});if(arguments.length){var __ilastarg0__=arguments.length-1;if(arguments[__ilastarg0__]&&arguments[__ilastarg0__].hasOwnProperty("__kwargtrans__")){var __allkwargs0__=arguments[__ilastarg0__--];for(var __attrib0__ in __allkwargs0__)switch(__attrib0__){case "current_features":var current_features=
__allkwargs0__[__attrib0__];break}}}else;if(current_features){reset_features();var current_features=dict(current_features);for(var [key,value]of current_features.py_items())py_values[key]=value}};export var on=function(feature_name){if(arguments.length){var __ilastarg0__=arguments.length-1;if(arguments[__ilastarg0__]&&arguments[__ilastarg0__].hasOwnProperty("__kwargtrans__")){var __allkwargs0__=arguments[__ilastarg0__--];for(var __attrib0__ in __allkwargs0__)switch(__attrib0__){case "feature_name":var feature_name=
__allkwargs0__[__attrib0__];break}}}else;return py_values.py_get(feature_name,false)};export var none=function(){if(arguments.length){var __ilastarg0__=arguments.length-1;if(arguments[__ilastarg0__]&&arguments[__ilastarg0__].hasOwnProperty("__kwargtrans__")){var __allkwargs0__=arguments[__ilastarg0__--];for(var __attrib0__ in __allkwargs0__);}var _=tuple([].slice.apply(arguments).slice(0,__ilastarg0__+1))}else var _=tuple();return true};export var any=function(){if(arguments.length){var __ilastarg0__=
arguments.length-1;if(arguments[__ilastarg0__]&&arguments[__ilastarg0__].hasOwnProperty("__kwargtrans__")){var __allkwargs0__=arguments[__ilastarg0__--];for(var __attrib0__ in __allkwargs0__);}var feature_names=tuple([].slice.apply(arguments).slice(0,__ilastarg0__+1))}else var feature_names=tuple();var __break0__=false;for(var feature_name of feature_names)if(py_values.py_get(feature_name,false))return true;if(!__break0__)return false};export var all=function(){if(arguments.length){var __ilastarg0__=
arguments.length-1;if(arguments[__ilastarg0__]&&arguments[__ilastarg0__].hasOwnProperty("__kwargtrans__")){var __allkwargs0__=arguments[__ilastarg0__--];for(var __attrib0__ in __allkwargs0__);}var feature_names=tuple([].slice.apply(arguments).slice(0,__ilastarg0__+1))}else var feature_names=tuple();var __break0__=false;for(var feature_name of feature_names)if(!py_values.py_get(feature_name,false))return false;if(!__break0__)return true};reset_features(false);

//# sourceMappingURL=features.map